/* autogenerated by Processing revision 1293 on 2025-01-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Sort extends PApplet {

boolean sound;

int frq = 1;
SinOsc sinWave;
//
// sinWave.play();
//
// sinWave.stop();

int BUBBLE = 0;
int SELECTION = 1;
int INSERTION = 2;

int RANDOM = 0;
int ASCENDING = 1;
int DESCENDING = 2;

int NUM_VALUES = 20;
int dataSize;
int maxValue;
int mode;
SortArray sorty;

boolean liveSort;

public void setup() {
  /* size commented out by preprocessor */;
  background(0);
  textSize(25);
  sinWave = new SinOsc(this);
  dataSize = NUM_VALUES;
  mode = RANDOM;
  maxValue = max(300, dataSize);
  sorty = new SortArray(BUBBLE, dataSize, maxValue, mode);
}//setup

public void draw() {
  background(0);
  sorty.display(true);
  if (liveSort) {
    sorty.sortOnce();
    if (!sorty.sorted) {
      //saveFrame("data/selection" + nf(frameCount, 4) + ".png");
    }
  }
  frq = sorty.getPosValue();
  sinWave.freq(frq + 200);
}//draw


public void keyPressed() {
  if (key == 'r') {
    reset();
  }//reset
  if (key == ' ') {
    liveSort = !liveSort;
  }
  if (keyCode == RIGHT) {
    sorty.sortOnce();
  }
  if (keyCode == UP) {
    sorty.resize(20);
  }
  if (keyCode == DOWN) {
    sorty.resize(-20);
  }
  if (key == 'b') {
    sorty.bubbleSort();
  }
  if (key == 's') {
    sorty.selectionSort();
  }
  if (key == 'i') {
    sorty.insertionSort();
  }
  if (key == '1') {
    sorty.algorithm = BUBBLE;
    reset();
  }
  if (key == '2') {
    sorty.algorithm = SELECTION;
    reset();
  }
  if (key == '3') {
    sorty.algorithm = INSERTION;
    reset();
  }
  if (key == 'a') {
    mode = ASCENDING;
    reset();
  }
  if (key == 'd') {
    mode = DESCENDING;
    reset();
  }
  if (key == 'q') {
    mode = RANDOM;
    reset();
  }
  if (key == 'm') {
    sound = !sound;
    if (sound) {
      sinWave.play();
    }
    else {
      sinWave.stop();
    }
  }
}//keyPressed

public void reset() {
  sorty.randInts(mode);
  sorty.resetSortVars();
}//reset for more sorting
/*==============================

  Complete:

  bubbleSort
  selectionSort
  insertionSort

  Each should run a FULL sort (instead of one step).
  Each should still keep track of comparrisons and swaps.
  The driver file will now respond to the following keypresses:
    'b': run fill bubbleSort
    's': run fill selectionSort
    'i': run fill insertionSort

  ==============================*/

class SortArray {

  int[] haystack;
  int maxValue;
  int algorithm;
  boolean sorted;

  //bubble sort vars
  int bsortEnd; //the last position to check when making a pass
  int bsortPos0; //the first position to compare each time
  int bsortPos1; //the second position to compare each time

  //Selection sort vars
  int ssortEnd; //the last position to check when making a pass
  int ssortPos; //the current position to check
  int ssortMaxPos; //the position of the largest value so far

  //insertion sort vars
  int isortEnd;
  int isortPos;
  int isortInsertPos;
  int isortValue;

  //analysis vars
  int swapCount;
  int compCount;

  SortArray(int algo, int dsize, int mvalue, int mode) {
    maxValue = mvalue;
    haystack = new int[dsize];
    randInts(mode);
    resetSortVars();
    algorithm = algo;
  }//constructor

  public void bubbleSort() {
  }//bubblesort

  public void selectionSort() {
  }//selectionSort

  public void insertionSort() {
  }//insertionSort


  public void sortOnce() {
    if (algorithm == BUBBLE) {
      bubbleSortOnce();
    }
    else if (algorithm == SELECTION) {
      SelectionSortOnce();
    }
    else if (algorithm == INSERTION) {
      insertionSortOnce();
    }
  }
  public void resetSortVars() {
    sorted = false;
    swapCount = 0;
    compCount = 0;

    //bubble sort vars
    bsortPos0 = 0;
    bsortPos1 = 1;
    bsortEnd = haystack.length;

    //selection sort vars
    ssortEnd = haystack.length;
    ssortPos = 1;
    ssortMaxPos = 0;

    //inseration sort vars
    isortEnd = 1;
    isortPos = 1;
    isortValue = haystack[isortEnd];
  }//resetSortVars

  public void insertionSortOnce() {
    if (isortEnd < haystack.length) {

      if (isortPos > 0) {
        compCount++;
        if (haystack[isortPos-1] > isortValue) {
          haystack[isortPos] = haystack[isortPos-1];
          swapCount++;
          isortPos--;
        }//shifting
        if (isortPos == 0 || haystack[isortPos-1] <= isortValue) {
          haystack[isortPos] = isortValue;
          isortEnd++;
          if (isortEnd != haystack.length) {
            isortPos = isortEnd;
            isortValue = haystack[isortPos];
          }
        }//inserting
      }
    }//still sorting
    else {//(isortEnd == haystack.length) {
      sorted = true;
    }//done
  }//insertionSortOnce

  public void bubbleSortOnce() {
    //if we haven't gotten to the front, we need to sort
    if (bsortEnd > 0) {

      //if we haven't reached the sorted portion, keep going
      if (bsortPos1 < bsortEnd) {
        //if the test values are out of order, swap 'em
        compCount++;
        if (haystack[bsortPos0] > haystack[bsortPos1]) {
          swap(bsortPos0, bsortPos1);
          compCount--;//offsetCompcount needed due to the else below
        }//sawp

        //move test positions over
        else {//else is only needed to see the swapping
          bsortPos0++;
          bsortPos1++;
        }
      }//working through a pass

      //if we've reached the sorted portion
      //rest for the next pass
      if (bsortPos1 == bsortEnd) {
        bsortPos0 = 0;
        bsortPos1 = 1;
        bsortEnd--;
      }//set up next pass
    }//still need to sort

    //if we did reach the front, set sorted to true
    else {
      sorted = true;
    }
  }//bubbleSortOnce


  public void SelectionSortOnce() {

    if (ssortEnd > 0) {

      if (ssortPos < ssortEnd) {
        compCount++;
        if (haystack[ssortPos] > haystack[ssortMaxPos]) {
          ssortMaxPos = ssortPos;
        }//sawp
        ssortPos++;
      }//working through a pass

      if (ssortPos == ssortEnd) {
        ssortEnd--;
        swap(ssortMaxPos, ssortEnd);
        ssortPos = 1;
        ssortMaxPos = 0;
      }//set up next pass
    }//still need to sort
    else {
      sorted = true;
    }
  }//bubbleSortOnce



  /*
  Utility Functions, Leave Alone
  */
  public int getPosValue() {
    if ( sorted ) {
      return -1;
    }
    if (algorithm == BUBBLE) {
      return haystack[bsortPos1];
    }
    if (algorithm == SELECTION) {
      return haystack[ssortMaxPos];
    }
    if (algorithm == INSERTION) {
      return haystack[isortPos];
    }
    else {
      return -1;
    }
  }



  public void swap(int p0, int p1) {
    int tmp = haystack[p0];
    haystack[p0] = haystack[p1];
    haystack[p1] = tmp;
    swapCount++;
  }//swap

  public void randInts(int mode) {
    for (int i=0; i<haystack.length; i++) {
      if (mode == RANDOM) {
        haystack[i] = PApplet.parseInt(random(maxValue));
      }
      else if (mode == ASCENDING) {
        haystack[i] = i+50;
      }
      else if (mode == DESCENDING) {
        haystack[i] = height - 50 - i;
      }
    }//loop

  }//randInts

  public void resize(int offset) {
    dataSize += offset;
    if (dataSize <= 0) {
      dataSize = 20;
    }
    haystack = new int[dataSize];
    randInts(RANDOM);
    resetSortVars();
  }//resize

  public void showStats(boolean advanced) {
    fill(255);
    textAlign(LEFT, TOP);
    if (algorithm == BUBBLE) {
      text("Bubble Sort", 0, 0);
    }
    else if (algorithm == SELECTION) {
      text("Selection Sort", 0, 0);
    }
    else if (algorithm == INSERTION) {
      text("Insertion Sort", 0, 0);
    }
    String stats = "n: " + haystack.length;
    if (advanced) {
      stats+= "\ncomps: " + compCount;
      stats+= "\nswaps: ";
      if (algorithm == INSERTION){
        stats+= swapCount/3;
      }
      else {
        stats+= swapCount;
      }
    }//display advanced stats
    textAlign(RIGHT, TOP);
    text(stats, width, 0);
  }//showStats

  public void display(boolean advanced) {
    float x = 0;
    float barWidth = width/PApplet.parseFloat(dataSize);
    noStroke();
    for(int i=0; i<haystack.length; i++) {
      fill(255);
      if (algorithm == BUBBLE && i >= bsortEnd ||
          algorithm == SELECTION && i >= ssortEnd ||
          algorithm == INSERTION && i < isortEnd) {
        fill(255, 0, 255);
      }//color sorted area
      rect(x, height, barWidth, -haystack[i]);
      x+= barWidth;
    }//loop through array
    if ( !sorted ) {
      sortHighLights();
    }
    showStats(advanced);
  }//drawValues

  public void sortHighLights() {
    float barWidth = width/PApplet.parseFloat(dataSize);

    if (algorithm == BUBBLE) {
      fill(255, 255, 0);
      rect(barWidth*bsortPos0, height, barWidth, -haystack[bsortPos0]);
      rect(barWidth*bsortPos1, height, barWidth, -haystack[bsortPos1]);
    }//bubble sort highlights

    if (algorithm == SELECTION) {
      fill(255, 255, 0);
      rect(barWidth*ssortPos, height, barWidth, -haystack[ssortPos]);
      fill(0, 255, 255);
      rect(barWidth*ssortMaxPos, height, barWidth, -haystack[ssortMaxPos]);
    }//bubble sort highlights

    if (algorithm == INSERTION) {
      fill(255, 255, 0);
      rect(barWidth*isortPos, height, barWidth, -haystack[isortPos]);
      fill(0, 255, 255);
      rect(barWidth*isortPos, height, barWidth, -isortValue);
    }
  }//sortHighLights

}//sortArray


  public void settings() { size(600, 400); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Sort" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
